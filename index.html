<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Proxy Scraper - IP + PORT</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 960px; margin: 40px auto; padding: 16px; background: #f4f6f9; }
  h1 { font-size: 1.6rem; margin-bottom: 8px; }
  textarea { width: 100%; height: 180px; font-family: monospace; border-radius: 8px; padding: 8px; border: 1px solid #ccc; resize: vertical; }
  button { padding: 10px 14px; border: none; border-radius: 8px; background: #007bff; color: #fff; font-size: 15px; cursor: pointer; }
  button:disabled { opacity: 0.6; cursor: default; }
  .log { background: #fff; border: 1px solid #ddd; padding: 10px; border-radius: 8px; white-space: pre-wrap; height: 180px; overflow-y: auto; margin-top: 12px; font-family: monospace; font-size: 13px; }
  .row { display: flex; gap: 8px; margin-top: 10px; align-items: center; }
  .status { margin-left: 10px; color: #555; }
  .progress { height: 10px; background: #e4eaf3; border-radius: 8px; overflow: hidden; margin-top: 8px; }
  .progress-bar { background: #007bff; width: 0%; height: 100%; transition: width 0.3s; }
</style>
</head>
<body>
  <h1>Proxy Scraper (IP + Port)</h1>
  <p>Masukkan daftar URL proxy (satu per baris). Semua format (HTTP, SOCKS4/5, HTTPS) akan digabung jadi format <code>IP:PORT</code>.</p>

  <textarea id="urls" placeholder="https://example.com/proxylist.txt
https://example.net/socks5.txt"></textarea>

  <div class="row">
    <button id="startBtn">Start Scrape</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="downloadBtn" disabled>Download proxy.txt</button>
    <span class="status" id="status">Ready</span>
  </div>

  <div class="progress"><div class="progress-bar" id="prog"></div></div>
  <div class="log" id="log">Menunggu...</div>

<script>
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else init();

function init() {
  const $ = id => document.getElementById(id);
  const logEl = $('log');
  const statusEl = $('status');
  const progEl = $('prog');
  const urlsEl = $('urls');
  const startBtn = $('startBtn');
  const stopBtn = $('stopBtn');
  const downloadBtn = $('downloadBtn');

  let aborted = false;
  let results = new Set();
  let running = false;
  const controllerMap = new Map();

  const log = msg => {
    logEl.textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  };
  const setStatus = msg => statusEl.textContent = msg;
  const setProgress = p => progEl.style.width = p + '%';

  async function fetchText(url, timeout = 15000, id) {
    const controller = new AbortController();
    controllerMap.set(id, controller);
    const timer = setTimeout(() => controller.abort(), timeout);
    try {
      const res = await fetch(url, { signal: controller.signal });
      return await res.text();
    } finally {
      clearTimeout(timer);
      controllerMap.delete(id);
    }
  }

  function extractProxy(text) {
    // Buang protokol
    text = text.replace(/\b(?:https?|socks[45]?):\/\/(?:\S+@)?/gi, '');
    // Cari IP + PORT
    const regex = /\b((?:\d{1,3}\.){3}\d{1,3}):(\d{1,5})\b/g;
    const found = [];
    let m;
    while ((m = regex.exec(text)) !== null) {
      const ip = m[1];
      const port = m[2];
      const validIp = ip.split('.').every(o => o >= 0 && o <= 255);
      const validPort = +port >= 1 && +port <= 65535;
      if (validIp && validPort) found.push(`${ip}:${port}`);
    }
    return found;
  }

  async function scrape(urls) {
    const total = urls.length;
    let done = 0;
    setProgress(0);
    setStatus(`0 / ${total}`);
    results.clear();

    for (let i = 0; i < urls.length; i++) {
      if (aborted) break;
      const url = urls[i];
      log(`ðŸ” Fetch: ${url}`);
      try {
        const text = await fetchText(url, 15000, i);
        const proxies = extractProxy(text);
        proxies.forEach(p => results.add(p));
        log(`âœ… ${proxies.length} proxy ditemukan`);
      } catch (err) {
        log(`âŒ Gagal ambil ${url} (${err.message || err})`);
      }
      done++;
      setProgress((done / total) * 100);
      setStatus(`${done} / ${total}`);
    }
  }

  startBtn.addEventListener('click', async () => {
    if (running) return;
    const urls = urlsEl.value.split(/\r?\n/).map(x => x.trim()).filter(Boolean);
    if (!urls.length) return alert('Masukkan minimal 1 URL!');
    logEl.textContent = '';
    aborted = false;
    running = true;
    results.clear();
    startBtn.disabled = true;
    stopBtn.disabled = false;
    downloadBtn.disabled = true;
    setStatus('Mulai scraping...');
    setProgress(0);

    await scrape(urls);

    running = false;
    stopBtn.disabled = true;
    startBtn.disabled = false;

    if (aborted) {
      setStatus('âŒ Dibatalkan');
      log('âš ï¸ Proses dibatalkan oleh user');
      return;
    }

    const arr = Array.from(results).sort();
    if (arr.length === 0) {
      log('âš ï¸ Tidak ada proxy ditemukan.');
      setStatus('Selesai (0 hasil)');
      return;
    }

    log(`ðŸŽ‰ Selesai! Ditemukan ${arr.length} proxy unik.`);
    setStatus(`âœ… ${arr.length} proxy siap diunduh`);
    setProgress(100);

    const blob = new Blob([arr.join('\n')], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    downloadBtn.dataset.url = url;
    downloadBtn.disabled = false;
  });

  stopBtn.addEventListener('click', () => {
    aborted = true;
    for (const c of controllerMap.values()) c.abort();
    controllerMap.clear();
    stopBtn.disabled = true;
    setStatus('Aborting...');
  });

  downloadBtn.addEventListener('click', () => {
    const url = downloadBtn.dataset.url;
    if (!url) return;
    const a = document.createElement('a');
    a.href = url;
    a.download = 'proxy.txt';
    a.click();
    URL.revokeObjectURL(url);
    downloadBtn.disabled = true;
  });
}
</script>
</body>
</html>
